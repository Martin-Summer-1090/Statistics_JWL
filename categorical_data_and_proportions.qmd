#Categorical Data and Proportions

The death of a child is an enormous tragedy to its family and friends. The numbers
across the globe add up to millions. From 56 million people who died for example in the year
2017, 5.4 millions were children under the age of 5, as reported by Max Roser [@Ros]
in an interesting article on the website "Our world in Data" which we referred to
in our introduction to this course. This is a number of enormous scale that never makes the
headlines.

Max Roser [@Ros] on the website "our world in data", we have encountered in the introduction,
puts the scale very vividly into perspective. He writes:

"...*The suffering and dying of children remains immense, yet these daily tragedies continue without receiving the attention this injustice deserves. A comparison of the tragedy of child deaths with those tragedies that do receive public attention puts it in perspective. A large jumbo jet can carry up to 620 passengers. The number of child deaths is that of 24 jumbo jet crashes, with only children on board, every single day. Single events – such as plane crashes – always make the headlines. Daily tragedies – even the worst ones like the deaths of thousands of children – never make the headlines.*

In pre-industrial societies infant and child mortality were uniformly and cruelly high. They
were a universal and frequent experience for families all over the world. 
In a scientific publication Anthony Volk 
and Jeremy Atkinson made an attempt  to report mortality 
rates of infants and children in the past, collecting data from a wide 
range of geographic locations and cultures reaching far
into the past [@VolAtk2013]. The mortality rate is defined as the number
of deaths per 1000 life births. 

The authors find that in the entire sample about 27 % of children 
died in their first year of life and 46 % died before they reached adulthood. These
rates are surprisingly similar across regions and cultures: Every forth newborn child died in the
first year of life, every second child during its childhood. These are truely 
grim numbers.

The numbers started to improve, very gradually only with the onset of industrialization. 
Gapminder, the
site we have already encountered in the introduction has 
collected and commented the available data back to 1800.^[See https://www.gapminder.org/data/documentation/gd002/]

Let us have a look at them. For instance, if we go back to 1850, we have data only 
from Europe.

```{r}
#| label: infant-mortality-1860
#| tbl-cap: Infant mortality in some European countries in 1860
#| warning: false

# read data from data folder. The data are a csv version of the excel file from gapminder
# sheet data

infant_mortality <- read.csv("data/infant_mortality/infant_mortality_data_gm.csv")

# when we read the data all years are read sa characters with X as prefix, like X1850. We want
# to remove the X

names(infant_mortality) <- as.numeric(sub("X", "", names(infant_mortality), fixed = T))

# replace Infant.Mortality.Rate by country

names(infant_mortality)[1] <- "Country"

# transform to a long format and add to the counts a column with the mortality rate. The rate
# is defined as the number of death during the first year of life per 1000 life births.

library(tidyverse)

data <- as_tibble(infant_mortality)


mort_dat <- pivot_longer(data, !Country, names_to = "Year", values_to = "Count",  
                         values_transform = list(Count = as.numeric))

mort_dat$"Mortality Rate" <- ifelse(is.na(mort_dat$Count), NA, mort_dat$Count/1000)

# table for 1860

rate_1860 <- with(mort_dat, mort_dat[Year == 1860, c("Country", "Count", "Mortality Rate")]) %>% na.omit()

library(knitr)
kable(rate_1860[order(-rate_1860$"Mortality Rate"), ], digits = 3)
write.csv(rate_1860, file = "tables/table_2_1_infant_mortality_1860.csv", row.names = FALSE)
```

The table shows the counts of infant death during the first year in the year 1860 per 
1000 life births. Before we deal with the information conveyed by these data, let us take the
opportunity to discuss some terminology and technical terms that will be a focus of this
chapter. 

The data are shown here in a table. We have ordered the countries by the infant mortality rate, 
displaying the country with the highest rate first. 
The columns of the table are called *variables*. So 
the variables shown in this table are Country, Count and Mortality Rate. In the specific
example shown here we have data that record whether an event has happened or not, in our case the
death of an infant in his first year of life in a specific country during a specific year. 
Variables that can take only two values, are called **binary data**. Sets of binary data can
be summarized by the number of times and the percentage of cases in which an event has occurred.

The basis for computing the percentages in our case are 1000 life births. So in the case of
Norway in 1860 we can report the data by saying that among 1000 life births we had 102 
infant deaths in the first year of life. Expressed as a rate this would be $\frac{102}{1000}$, or
$0.102$, which amounts to $10.2$ percent.^[Remember from school mathematics that a percentage is a number or ratio expresses as a fraction of 100. It is often denoted by the
percentage sign %. A percentage is a dimensionless number. It has no unit of measurement. For
example 45 % is the fraction $\frac{45}{100}$ or 0.45. Percentages are often used to express
a proportionate part of the total. Thus when we see in the table that the mortality rate in
Germany in the year 1860 is 0.260 this is expressed in percent as mortality rate of 26 %.]

Each row in the table
is a *record* or sometimes also called an *observation*. Our table shown here has eight records. 
For doing statistics, especially when using the computer, it is often useful to display 
data tables such that each variable is a column and each record is a row.^[Such a format is
not always the reader friendliest to humans and thus data on the web are often 
organized differently. For example the Gapminder data show the Years as columns and countries
as rows. While easier to read such a table for working with the computer this deviation from
the format variable as column and observation as row, often creates problems. We will come back
to this seemingly minor but in fact quite important point over and over again. 
Hadley Wickham [@JSSv059i10], who
has contributed a lot to R and the R programming language which we will use in 
this course has popularized
the term "tidy" for the table format where every column is a variable and every row is an
observation.]

In this chapter we will use counts and proportions as the leading example to discuss the
basic presentation of statistics and data. We will learn about alternative ways to display data.
You will learn how design choices for the display of data help or prevent engagement and 
readability for your respective audience. You will also learn the 
first steps in R and how to use the computer to analyze and communicate data.

## Communicating Counts and Proportions

Let us follow the history of infant mortality around the globe. When we looked at the 1860-ies
rates of infant mortality were very high, not much better than it had been all the centuries
before industrialization has set in in Europe. 

But then about 100 years later we already see a significant reduction in the Western countries, 
with rates reduced still much further until now in the most affluent countries. Let us look at 
the country group for which we had data in 1860 already, again today in 2020,
before we go to the global picture. We will use this example to discuss some important aspects
of communication counts and proportions. Again we have ordered the observation by a decreasing
mortality rate.

```{r}
#| label: infant-mortality-2020
#| fig-cap: Infant mortality in some European countries in 2020.
#| warning: false

#read data from the data file our world in data

im_1960_2020 <- read.csv("data/infant_mortality/infant-mortality.csv")

names(im_1960_2020) <- c("Country", "Code", "Year", "Mortality Rate")

# Select variables to be consistent with previous format

im_1960_2020 <- im_1960_2020[c("Country", "Year", "Mortality Rate")]

# Select the country group used in the historical 1860 data

dat_sel <- im_1960_2020[im_1960_2020$Country %in% c("Germany", "Austria", "Netherlands", "Spain", "France", "Belgium", "Denmark", "Sweden", "Norway") & im_1960_2020$Year == 2020, ]

# In the data the mortality rate is given in percent. We add the corresponding counts

dat_sel$Count <- (dat_sel$"Mortality Rate"*10) 

# We transform the percentage rate to the actual rate of number of death per 1000 life births

dat_sel$"Mortality Rate" <- dat_sel$Count/1000

# reorder columns

dat_sel <- dat_sel[, c("Country", "Year", "Count", "Mortality Rate")]

# display the table and write text file of table

library(knitr)
kable(dat_sel[order(-dat_sel$"Mortality Rate"), ], digits = 4)
write.csv(dat_sel, file = "tables/table_2_2_infant_mortality_2020.csv", row.names = FALSE)

```

This is a spectacular improvement for this group of countries. 
Within a bit more than a century the
mortality rate has been reduced from 30 % to below 0.3 %. This amounts to 
a reduction by a factor of about 100.
Isn't this a stunning achievement?

As Vaclav Smil
has pointed out in a recent book [@Smil2020] such low rates are impossible 
without the combination
of a number of critical conditions, such as good healthcare in general, appropriate 
prenatal, perinatal and neonatal care, proper maternal and infant nutrition, adequate 
sanitary living conditions as well as access to social support for 
disadvantages families. All of
these factors require relevant government and private spending and on 
infrastructures that can be
universally used and accessed. Infant mortality is thus a very powerful 
indicator of quality of life in a country.

When data, such as counts and proportions are reported in a table we should make careful
considerations how the data are precisely presented. 

For instance in the table about infant mortality in some European countries in 1860,
we could have reported the same information by
presenting survival rates instead of mortality rates. Such a choice in reporting is 
generally known as *framing*. Framing can have effects on the impact of communication. 
Depending on how you frame the communication of data, the same information might 
affect and engage your audience differently. The same table with survival rates instead
of mortality rates would the look like this.

```{r}
#| label: infant-survivial rate-1860
#| tbl-cap: Infant survival rates in some European countries in 1860
#| warning: false

# read data from data folder. The data are a csv version of the excel file from gapminder
# sheet data

infant_mortality <- read.csv("data/infant_mortality/infant_mortality_data_gm.csv")

# when we read the data all years are read sa characters with X as prefix, like X1850. We want
# to remove the X

names(infant_mortality) <- as.numeric(sub("X", "", names(infant_mortality), fixed = T))

# replace Infant.Mortality.Rate by country

names(infant_mortality)[1] <- "Country"

# transform to a long format and add to the counts a column with the mortality rate. The rate
# is defined as the number of death during the first year of life per 1000 life births.

library(tidyverse)

data <- as_tibble(infant_mortality)


mort_dat <- pivot_longer(data, !Country, names_to = "Year", values_to = "Count",  
                         values_transform = list(Count = as.numeric))

mort_dat$"Survival Rate" <- 1 - ifelse(is.na(mort_dat$Count), NA, mort_dat$Count/1000)

mort_dat$Count = 1000 - mort_dat$Count

# table for 1860

rate_1860 <- with(mort_dat, mort_dat[Year == 1860, c("Country", "Count", "Survival Rate")]) %>% na.omit()

library(knitr)
kable(rate_1860[order(rate_1860$"Survival Rate"), ], digits = 3)
write.csv(rate_1860, file = "tables/table_2_3_infant_survival_1860.csv", row.names = FALSE)
```




Take for instance the data for Germany 1860. If we had
reported a survival rate of 74 % it might sound to many better than if we had reported the
equivalent information of a mortality rate of 26 %. So whenever you report
counts or proportions be mindful of framing effects.

Risk impression can often be made more clear if we report the actual counts as well as  
the percentages. The count or total number can then be imagined as an actual crowd of
people. For example we could visualize the infant mortality rate in Germany by creating
a picture of the counts of cases (infant deaths) among 1000 life births.

Such a visualization could then look for example like this:

```{r}
#| label: infant-mortality-isotype-1860
#| fig-cap: In 1860 in Germany among 1000 newborns 260 infants died in the first year of their life.

library(waffle)
waffle(c("Death" = 260, "Survived" = 740), rows = 20, colors = c("#FD6F6F", "#93FB98"), use_glyph = "child", glyph_size = 4, equal = F)
```
Here you visualize the numbers as differently colored crowds. It makes the magnitude
of the mortality rate (as well as the survival rate) tangible. When you plot the
same graph for the data of 2020 the enormous improvement that took place within a time
span of one and a half centuries in Germany become perhaps more obvious that looking at the
rates alone. The same kind of visualization for the 2020 data would then look like this

```{r}
#| label: infant-mortality-isotype-2020
#| fig-cap: In 2020 in Germany among 1000 newborns 3 infants died in the first year of their life.

library(waffle)
waffle(c("Death" = 3, "Survived" = 997), rows = 20, colors = c("#FD6F6F", "#93FB98"), use_glyph = "child", glyph_size = 4, equal = F)
```


A very interesting and illustrative example for how imagining actual crowds of 
people rather than mere rates is given in the book by David Spiegelhalter[@Spi2019], which 
we have already encountered when we discussed the issue of
how many trees there are on the planet in the introduction. He describes
an advertisement in the London Underground, saying that 99 % of young Londoners 
do not commit serious violence. The add was presumably intended to reassure
passengers about the safety situation. Here is what he writes:

"...*we could reverse the emotional impact by two simple changes: First the statement means that 1 % of young Londoners do commit serious violence. Second, the population of London is around 9 million, there are around 1 million people aged between 15 and 25, and f we consider these as "young", this means there are 1 % of a million or a total of 10.00 seriously violent young people in the city. This does not sound at all reassuring. Note the two tricks used to manipulate the impact of this statistic: Convert from a positive to a negative frame, and then turn a percentage to an actual number of people.*"

A standard we should strive for when reporting data is providing impartial information. 
For this
we should think carefully about our framing and should perhaps provide 
both positive and negative
frames. But even if we achieve this, we should consider other things, like the ordering
of the rows.

In this discussion the countries were presented ordered according to decreasing 
infant mortality rates. This
choice of display might create the impression that this was an important and valid way of 
comparing and ranking countries. 

While such rankings are popular 
in the media we should avoid such
displays of information when there is no specific reason
to display a ranking. 

First of all the differences could be there just by chance. Furthermore
countries with low infant morality rates usually have low population numbers smaller than 10 
million. They include the world's most homogeneous societies, like Japan, south Korea, 
Iceland, Finland and Norway. A country with a large and heterogeneous population, will 
find it difficult to achieve the same infant mortality rate as a small and homogenous country. 

## Visualizing infant mortality rates: First steps in R

While a table might be the medium of choice for displaying data  it is 
often more powerful to
convey information visually. The example of how imagining actual crowds might give us
sometimes a more tangible picture of the same information, was one illustration of this.

Today when we visualize data as one important tool of data exploration, the tool of choice
is a computer and an appropriate language that enables us to tell the computer what to do. 

For us in this course this will be the R language and now we start to learn the first steps 
in this language.

### Starting an quitting R

We assume that the computer you work with has a recent version of R installed. R will work
with the most common operating systems such as Windows, OSX or Linux.^[Installing R 
yourself is not complicated. You get the newest version of R at the website https://cran.r-project.org/. A screenshot of the website is here ![cran-website](pictures/cran-website-as-of-2022-09.png)] 

We will use R in two
ways: First from the R command line and then also by working with Jupyter Notebooks.^[Another very powerful and popular program to work with R and R code is RStudio, which you can find 
here https://www.rstudio.com/. RStudio is a so called IDE, an integrated development environment. If you have access to a computer with internet connection and the permissions to
install software yourself, feel free to experiment also with this tool. The basic version is
free of charge.]

The
notebooks, which we already encountered in an example in the introduction, 
will not only allow to send command to R and execute these commands but in addition
also to store command, comment them and make them available as files for later use.

For a start we just work with the R command line or the R-console, as it is called, introducing
the use of R via the notebooks a bit later. You start R by either typing `R` into the 
terminal or by clicking the R icon. To end your R session write `quit()` at the 
prompt `>` of the console. Congratulations. Now that you can start and quit R we are ready to 
go.

### First steps

The R command prompt is `>`. When R shows the prompt, it says that it is ready to receive commands. You type the commands at the prompt.

Here is an easy command you can send to R. Just try to type `1 + 1` at the prompt

```{r}
#| code-fold: false
1 + 1
```

Sure enough, R gives you the result of the addition, which is `2`. But what is
`[1]`? This is just a row lable. We will go into that later. 

So R can do all the
usual computations. For instance if you knew that in Germany in 1860 there were 270
infant death per 1000 life birth you could compute the mortality rate by typing

```{r}
#| code-fold: false
270/1000
```

you will get the mortality rate `0.27`.


R needs a complete command to be able to execute it, when the return key is pressed. 
Lets see what happens, if a command is incomplete, like for instance:

`5*`

In this case R will show the expression followed by a `+` instead of showing a new prompt. This
means that the expression is incomplete. It expects more input.
If we complete the expression, the expression can be evaluated and a new prompt is shown in the console.


If you type a command that R does not understand, you will be returned an error message. 
Don't worry if you see an error message. It just is a way the computer tells you that he does 
not understand what you
want him to do.

For instance, if you type `5%3` you will get an error message like this

```{r}
#| code-fold: false
#| error: true

5%3
```

Sometimes it is obvious why a mistake occurred. In this case, that R just does not 
know what to do with
the symbol `%`. It has no meaning in this context. Sometimes it is 
not so obvious what the error
message actually means and what you might do about it. 

A useful strategy in this 
case is to type
the error message into a search engine and see what you can find. The chance is very 
high that others
encountered the same problem before you and got helpful advice how to fix it from other users on 
the internet. One site, we find particularly helpful for all kinds of questions related to R
and R programming is https://stackoverflow.com/. Try it at the next opportunity.

With this knowledge we can already do a first example, by continuing our disucssion
on infant mortality data we started in this lecture. We now use R to read a dataset 
showing the mortality rates by groups of countries categorized by their income levels as 
well as for the world as a whole. 

One of the great features of R is that it comes with many built in functions that perform
certain tasks, like for instance reading data or making particular plots with these data.
In this example we read data provided in a very common format, the csv format. Csv is an
abbreviation of comma separated values. A csv file is a raw text file, containing data with
different data points separated by commas (or sometimes semicolons). 

In R a function has a name followed by parenthesis, which can take inputs or arguments, like this:

```{r}
#| code-fold: false
read.csv("tables/table_2_2_infant_mortality_2020.csv")
```

You can recognize this table. It is the same table of infant mortality rates among some
European countries in 2020, we looked at before in a slightly different format. These
data are stored on my machine in a particular folder. The pathname to the folder "tables/table_2_2_infant_mortality_2020.csv" is an argument to the function `read.csv()` 
telling R to which file the function should be applied. When we execute the function
by pressing the enter key, R reads the file and displays its contents.

We can save data in R by stroing them in *objects*. An object is a name, you 
can choose yourself to
store data. For example, if you choose to store the output of the function
call to `read.csv()`in an object called `dat`,
you would type:

```{r}
#| code-fold: false
dat <- read.csv("tables/table_2_2_infant_mortality_2020.csv")
```

R will now store the output of the function call, the data table, in an object called `dat`. 
You can use this object name now to refer to it. For instance if you now type

```{r}
#| code-fold: false
dat
```

the value that is stored in the object will be printed to the screen. In this case
the table will be displayed. 

We now use this fact an make our first own graph. Instead of showing the rates in a table,
we rather want to display in in a bar chart. R has a built in function for such charts, which
is called `barplot()`. The `barplot()` function takes as arguments the data and perhaps other
arguments influencing the appearance of the plot, and produces a graphics.

For the plot we need the mortality rates, not the whole object dat. We will learn how we extract
subsets of data from a large table systematically in the next unit. Here we just show you, how
we do it for this particular example. We extract the mortality rate column from the table by 
tying `dat$Mortality.Rate` and store it in a new object which we choose to call `mr`.

```{r}
#| code-fold: false
mr <- dat$Mortality.Rate
```

We have extracted the column with the name "Mortality.Rate" from the object `dat` and stored
it in a new object which we have called `mr`. Now let us make the barplot.

```{r}
#| code-fold: false

barplot(mr)
```

It would be easier, if we had the plot turned horizontal. This can be achieved by 
specifying further arguments. We will learn later how we can find out which arguments can
be used with a function by accessing the documentation. For `barplot()`it turns out that
there is an argument, called `horiz` which has the logical value `FALSE` but which can be
set to the logical value `TRUE`, yielding what we want:

```{r}
#| code-fold: false
barplot(mr, horiz = TRUE)
```

But which bar belongs to which country? Here we can specify the countries again by a new
function argument, which is called `names.arg` for the boxplot function. We assign the
column of country names in `dat`to this argument.

```{r}
#| code-fold: false
#| fig-cap: Infant mortality in some European countries in 2020.
barplot(mr, horiz = TRUE, names.arg = dat$Country, 
        las = 1, cex.names = 0.5)
```

Now we have visualized the information we had displayed in a table before. What do these
other strange labels mean? `las` is an additional argument to the function which will make
the country names on thy y-axes appear horizontally. `cex.names` is an argument that will scale
down the font size of country names such that the names do not exceed the frame and
become unreadable.

Don't worry if this first encounter with R and R functions might look a bit duanting and
not very systematic. We will learn to visualize data much more systematically as we go through
the course. For now you have seen a very direct way how to visualize some of our data in very
few steps.

Before I end the discussion of this first encounter with R and visualization, let me point
out an important point about the display of proportions or rates in a (horizontal) bar
chart. It is usually a good idea, to choose the origin of the graph, as we have done here,
at 0. If we choose the origin somewhere else, differences might look much bigger. This
is by the way a standard trick of manipulative display of data. With bar charts always be
mindful about the choice of origin.

To see this point, let us choose the origin, say at 0.0015 instead of 0. R allows us to do
so very easily. The barplot function allows for setting the origin for the x-axes at a
particular value with the `xlim` argument.

```{r}
#| code-fold: false
#| fig-cap: Infant mortality in some European countries in 2020, different origin.
barplot(mr, horiz = TRUE, names.arg = dat$Country, 
        las = 1, cex.names = 0.5, xlim = c(0.0015, 0.0037), xpd = FALSE)
```

Now the differences suddenly look bigger. 

Before we end these first steps in R, note that each R function comes with its own 
help documentation, which you can access by typing

```{r}
#| code-fold: false

?barplot
```

function. It will show you the documentation for the function, describing what it does, what the
parameters mean and also at least one example for calling the function 



<!-- ## Contents -->

<!-- Introduce binary variables, variables that can be imagined as yes-no questions and how they can be summarized as proportions. -->

<!-- 1. The importance of framing -->
<!-- 2. Relative and absolute risk -->
<!-- 3. How to think in expected frequencies can promote understanding and provide an appropriate sense of importance, what are odds rations, why we need to understand what they mean and why we should avoid them in communication. -->
<!-- All these concepts and discussions should be accompanied by data visualization and students will learn how to visualize the data on the computer. -->

<!-- ## Outcome -->

<!-- The outcome of learning from the introduction and this chapter, which together form unit 1, students should have an overview of -->

<!-- 1. The contents of the course -->
<!-- 2. Should have formed expectations that this course will actively involve them and require their hands on participation -->
<!-- 3. Know how to start and stop R (Python) and R studio (Jupyter notebooks) and have played with one or two meaningful visualizations right away. -->

<!-- The way to achieve this is to prepare a visualization code in an interactive notebook, which students need not understand in all details. But they can change details, for instance if the variables contain countries, they could change the code such that the data for their own country are shown and rerun the visualization code. -->

<!-- After this unit the students should feel familiar with proportions and their meaning and interpretation. -->
<!-- We will also have gathered data from an activity which will be used later in the course. -->