# Summarizing and communicating lots of data

When we analyze data, we usually have to look at lots of them. An example might be
income data gained from household surveys. Such a survey will contain a huge number of
data points, in the order of magnitude of ten thousands of data. These data need to be
summarized, to understand their main characteristics. 

In this unit you will learn the
most important tools for summarizing and communicating lost of data. You are going to
learn the principles how data summaries are constructed, what are the properties of
these summaries and what needs to be carefully considered. 

When we need to deal
with really large data sets, and most modern data sets are too large to be handled manually,
we will need the computer. We already did some first steps in R. In this unit we will build on these
first steps but enlarge them in a way that will enable you to deal and manipulate large
datasets on the computer. 

## Understanding variation in a single variable using histograms

### Constructing a Histogram

To summarize data, statisticians often use a graph which is called a **histogram**. In this section
we will discuss all you have to know about histograms and how to use them. Let us start by an example,
where we have about 100 data points, which is a lot but not that large that we can not handle them 
by hand.

The data we want to look at come from measurements of the annual flow of the river Nile at 
Aswan (formerly) Assuan in Egypt from 1871 to 1970. The units of these measurement in which the
annual flow is recorded are 100 millions of cubic meters, i.e. $10^8 m^3$. 

This is one of the data sets that is bundled with the R distribution and is available to all users of R. 
They are stored in an R object called `Nile`.^[When you type `data()` at the R console, you get a list
of all datasets that are available with the current distribution of R.]

This is how the data look like, when we print them to the R console using the R command
`print()`. The R function `options()` with the argument `width`just controls how the
numbers are printed. Here I made sure that they will fit in the width of the page.

```{r}
#| code-fold: false
options(width = 70)
print(Nile)
```

We start the construction of a histogram by choosing for the horizontal axes ranges of numerical
values - in our case of the river flow data - which are called *bins* or *classes*. There is no
fixed rule as to how to choose the size of these ranges. These ranges should neither be too 
fine, nor too
coarse. While there are lists of mechanical rules, which you can for example find on Wikipedia^[See https://en.wikipedia.org/wiki/Histogram#Number_of_bins_and_width], it is usually best to use your domain
knowledge and some experimentation to find out the bin size that works best for your data.

For this example, assume we had chosen a bin size of 100^[Note that this will mean $100\times 10^8 m^3$ per year.]. When you study the list, you will find that the lowest value is at 456 while the highest value
is at 1370. This is already quite tedious to find out by eyeballing the numbers with the small 
number of values we have chosen for this example. It is impossible to do for really large data sets.

Now lets make a distribution table like this:

| Flow-bin   | Frequency |
|-----------:|----------:|
| 400 -  500 |          1|
| 500 -  600 |          0|
| 600 -  700 |          5|
| 700 -  800 |         20|
| 800 -  900 |         25|
| 900 - 1000 |         19|
|1000 - 1100 |         12|
|1100 - 1200 |         11|
|1200 - 1300 |          6|
|1300 - 1400 |          1|

In the column Flow-bin we have recorded the bins in steps of 100 and in the right column, Frequency, we
have recorded the count of values that are in this bin. 

When we make such a tabulation we have to agree on an endpoint convention. This is important, since 
when a flow value would for instance be measured as exactly 500, in which bin should it be counted:
400-500 or 500-600? You, the constructor of the histogram, has to take this decision. Let us
agree on the convention that when a value falls exactly at the endpoint of the bin, we
put it in the next bin. In practice you
will usually do a histogram by computer. The code of the computer program has to specify an endpoint
convention, so the computer knows what to do when a value coincides with an endpoint.

On the Frequency axes you put the frequency scale: Counts of values. Then for each bin, you plot
a bar, which has the width of the bin and the height of the frequency. 

Do this for all the bins
you have tabulated and you are ready.

The histogram provides a certain aggregation of the data because it sorts the 100 data points into 10
bins, in our example. While loosing some local information on individual data points the global information
conveyed by the summary gives us a pretty good idea of the overall pattern of variation on the Nile river
flow data. 

We can see, for instance, that the most frequent flow is between 800 and 900 and that the
variation is fairly symmetric around this bin. In the extremes this most frequent value can half or almost
double, so there is quite some spread in the data.

![Constructing the river flow histogram](pictures/nile_hist.png)

If we had just plotted all individual data points, we also got a picture, though you probably agree
that it is not particularly useful.

```{r}
plot(as.numeric(Nile), xlab = "Observation", ylab = "Annual Flow", pch = 16)
```

Histograms are such a common tool in statistics to explore the variation in one variable and the shape, how
it is roughly distributed that every statistical software has functions to produce histograms. In R, the
language we use in this course, there is also such a function. The function name is called `hist()` and it
takes the data as an argument. This is the second graphic function of R you encounter in this course
after we played with the `barplot()`function in the last lecture. 

To produce a histogram from the river flow data, we type at the console

```{r}
#| code-fold: false

hist(Nile)
```

:::{.callout-note icon=false}

### Now you try

Let us check your understanding of histograms by a little quiz now. The histogram below
shows the distribution of the final score in a certain class.

(a) Which block represents the people who scored between 60 and 80?
(b) Ten percent scored between 20 and 40 about what percentage scored between 40 and 60?
(c) About what percentage scored over 60?

![Final Score](pictures/final_score.png)
:::

### The density scale: Absolute versus relative frequency

Sometimes it might be useful, to choose a different scale for the y axes of your histogram. Instead
of absolute frequencies (or counts) it might be useful to show relative frequencies, the proportion
of occurrences in each bin. The type of scale you choose will depend on what kind of 
comparisons you want to emphasize about your data.

Let us look at this issue by an example. The numbers we want to look at report energy consumption per
capita in kwh per person per year for different countries around the world.^[A kilowatt-hour, known as Kwh
is a way to measure how much energy is used. A kilowatt-hour is the amount of energy used if
a 100 watt appliance is kept running for an hour. For instance, if you turned on a 100 watt bulb 
for one hour you are using a kilowatt-hour of energy. What’s the difference between kilowatt 
vs. kilowatt-hour? A kilowatt is 1,000 watts, which is a measure of power. A kilowatt-hour is a 
measure of the amount of energy a certain machine needs to run for one hour. So, if you have 
a 1,000 watt drill, it takes 1,000 watts (or one kW) to make it work. If you run that 
drill for one hour, you’ll have used up one kilowatt of energy for that hour, or one kWh. 
Obviously, every appliance will use a different amount of power. Here are some of the 
usages for some items in a home: 50″ LED Television: around 0.016 kWh per hour,
electric water heater: 380-500 kWh per month] 
The energy numbers 
refer to primary energy – the energy input before the transformation to forms of energy for 
end-use (such as electricity or petrol for transport).

Let us look at the
year 2019.

```{r}
library(JWL)
library(ggplot2)

dat <- with(energy_consumption_per_capita, energy_consumption_per_capita[Year == 2019, ])

hist_info <- hist(dat$Cons, plot = FALSE)         # Store output of hist function
hist_info$density <- hist_info$counts /    # Compute density values
  sum(hist_info$counts) * 100
plot(hist_info, freq = FALSE, xlab = "Primary energy consumption in kilowatt-hours per person per year.", ylab = "Percent", main = "Primary energy Consuption per Capita 2019")              # Plot histogram with percentages
```
In this histogram you see the distribution of per capita primary energy consumption for the year
2019 for countries around the globe. But now the y axes shows relative frequencies instead of counts.

For example, you see from the graph that roughly 55 % of countries have a primary energy consumption 
smaller that 20.000 kilowatt hours per person in this year. The next larger bucket contains already 
roughly half or 24 %. The biggest buckets are then a very small fraction of countries in the world. This
means that there is a relatively small share of counrties, around 20 %, which have a large
primary energy consumption per capita. One says in the language of statistics that the
distribution of per capita primary energy consumption is skewed. 

When you have a histogram with a density or relative frequency scale, the total area sums to 100 (or to 1
depending on how you express the percentages, i.e. whether you express them as 10 % or as 0.1.).

### Exercises: Now you try

1. A histogram of monthly wages for part-time employees is shown below (densities are marked in
parenthesis). Nobody earned more than $1000 a month. The block over the class interval from 200
to 300 is missing. How tall must it be?

![Wages](pictures/wages.png)
2. Three people plot histograms for the weights of subjects in a study, using the density scale. Only one is right. Which one and why?

```{r}

#| echo = false

library(JWL)

dat <- height_weight

data <- dat[dat$state == 1 & dat$sex == 1 & dat$age > 18, ]

hist_inf <- hist(data$height, plot = FALSE)         # Store output of hist function
hist_inf$density <- hist_inf$counts /    # Compute density values
  sum(hist_inf$counts) * 100

png(file="pictures/hight_version1.png")
plot(hist_inf, freq = FALSE, xlab = " ", ylab = " ", main = " ")


png(file="pictures/hight_version2.png")
plot(hist_inf, freq = FALSE, xlab = "hight (cm) ", ylab = "Percent per 5 cm ", main = " ")


png(file="pictures/hight_version3.png")
plot(hist_inf, freq = FALSE, xlab = "hight (cm) ", ylab = "5 cm per percent", main = " ")

```

::: {#fig-height_hist layout-ncol=3}
![Version 1](pictures/hight_version1.png){#fig-hight-hist-version1}

![Version 2](pictures/hight_version2.png){#fig-hight-hist-version2}

![Version 3](pictures/hight_version3.png){#fig-hight-hist-version3}

Three versions of a hight histogram of males over age 18
:::

3. An investigator draws a histogram for some height data, using the metric system. She is working in
centimeters (cm). The vertical axes shows density and the top of the vertical axes is 10 percent per cem. Now she wants to convert to millimeter (mm). There are 10 millimeter to the centimeter. On the 
horizontal axis, she has to change 175 cm to ? mm, 200 cam to ? mm. On the vertical axis she has to change 10 percent per cm to ? percent per mm, and 5 percent per cm to ? percent per mm.

4. In a Public Health Service study, a histogram was plotted showing the number of cigarettes per day smoked by each subject (male current smokers), as shown in the histogram below. The density is marked in
parentheses. The class interval include the right endpoint, not the left.

   (a) The percentage who smoked 10 cigarettes or less per day is around:

        1.5%    15%   30%   50%

   (b) The percentage who smoked more than a pack a day, but not more than 2 packs, is around

        1.5%    15 %    30%   50%
        (There are 20 cigarettes in a pack)

   (c) The percentage who smoked more than a pack a day is around

        1.5%,   15%,   30%,   50%

   (d) The percent who smoked more than 3 packs a day is around

        0.25 of 1%,    0.5 of 1%,     10 %

   (e) The percent who smoked 15 cigarettes per day is around

        0.35 of 1%,    0.5 of 1%,   1.5%,    3.5%,    10%
        
![Number of cigarettes](pictures/cigarettes.png){#fig-hight-cigarettes}

### Best practices for histograms

When you summarize lots of data by a histogram there are some things you should 
consider carefully. Let us go through the most important best practice 
principles for histograms.

#### Bin size

When doing exploratory data work it is usually a good idea not to look at a single 
histogram but at several histograms of the same data by changing the bin size. There
is no clear rule about the optimal bin size. It often depends on context and field 
knowledge. 

If the bins are to fine, then the data will be be very noisy and give no overview because
they show too many individual points. On the other hand if the bins are too wide, they
will not show you the overall variability in the data very well and you fail to
get a good idea about the distribution. 

Let us illustrate this point using the river flow data of the Nile. 

In the first case we have chosen 100 bins, which is too fine. There is almost one bar
for every single data point. In this way we have a lot of spurious peaks and throughs and can
not see the variation pattern in the data very clearly

```{r}
hist(Nile, breaks = seq(min(Nile), max(Nile), length.out = 100))
```
Now here we have the other extreme, lets assume we have only 3 bins. This would give us
a pattern like this.

```{r}
hist(Nile, breaks = seq(min(Nile), max(Nile), length.out = 3))
```
Here the histogram is too coarse and we do not see the variation pattern either. 

The computer usually has a built in rule of thumb for the histgram which will work well in most
of the cases. Still for individual datasets it is sometimes better to choose a different bin size
that more adequately mirrors the variation in the data.

#### Choose boundaries that can be clearly interpreted

Tick marks and labels should fall on the bin boundaries. As in the examples discussed
so far, they need not be there for every tick but it is enough if they are there between
every few bars. Bin labels should also have not many significant digits, so they are easy to
read. So bin sized which divide 10 and 20 evenly are easier to read than bin sizes that do not.
So always take caution not to arbitrarily split bin sizes. Otherwise you can end up with
off bin boundaries.

For example, if we just took the maximum and the minimum of the Nile river flow data and
arbitrarily divided them into 7 bins, we would get the difficult to read bin boundaries

```{r}
seq(min(Nile), max(Nile), length.out = 7)
```

instead of the more easily readable boundaries

```{r}
seq(400,1200,100)
```

#### What's the difference between a histogram and a bar chart?

A histogram depicts the frequency distribution of a continuous, quantitative variable, such 
as height, weight, time, energy consumption etc. These are variables that can take on any
value and these values can be ordered from smallest to highest.

When we have a categorical variable, like we encountered them in section 2, we need to use a bar chart.
The bars of the bar chart typically will have a small gap between the bars, emphasizing the discrete
nature of the variable. The categories in a bar chart usually have no natural ordering. As we discussed
in section 2, we have even to be conscious how we display the categories to avoid suggesting an
order that is in fact not there in the data.

## Next steps in R: Reading Data, understanding R objects and selecting and modifying values {#sec-moreR}

Before we go on with learning the tools to summarize and communicate lots of data let us
gain more skills for handling the tool that will actually enable you to handle
large data sets yourself by making use of R. Building on what we learned in the last unit, 
lets now push
your knowledge of R bit further.

### Reading data in R {#sec-readingdata}

Before we can do anything with data, we need first to learn how  to load data into R and how
to save them. We will discuss now how to do this for the case of *comma separated text files* or 
so called *csv* files. R provides functions 
for reading and writing from almost any other format, like data stored in
Excel files and many more data formats that are used today.
Since in all those different formats are read by R following the same principles 
as in the csv case, it is sufficient if we discuss here the the case of csv files only.

We have discussed a data set of per capita primary energy use in countries around the globe to
produce a histogram of these data for the year 2019. How did I get these data into R?

First of all I could access these data because helpful people at Oxford University in the UK who maintain
and run the website "Our world in data", which we have encountered before, store these data on their
website. In the concrete case of the energy data, they can currently be found at
https://ourworldindata.org/grapher/per-capita-energy-use
where you can download the datafile from the webpage and save it locally somewhere on your
computer. 

I have taken a screenshot here

![Our World in Data website energy](pictures/our_world_in_data_energy.png)

In the lower right corner you see a box called Data and a download button. This button allows you to 
download the dataset to your machine. The file is called `per-capita-energy-use.csv`. From the extension
of the file `csv`, you can see that it is a comma separated text file. This is a plain text file following
certain formatting rules. In particular individual data points are separated by a comma^[The standard format for csv can be looked up here https://www.ietf.org/rfc/rfc4180.txt. Despite this standardization
it can occur that different files use different conventions for the notation of the decimal comma sign. In the most common specification this symbols is a dot (.) and in others it is a comma (,). For such speical cases R provides special functions, which we will explain in the text.]

I have stored
the file in a sub-folder to the directory in which I am writing these lecture notes. If you decide to
download this file, you will save it somewhere on your machine where you find it appropriate. Perhaps
you have a folder for this course and in this folder you have a sub-folder where you store all the
data sets we are using in the course.

To read a csv file, R provides the function `read.csv()`. If the csv file
comes with a European instead of an US decimal format (`,` instead of `.` for the
decimal sign.) you need to use the function `read.csv2()`. Please check out the documentation
of these functions by typing `?read.csv` at the R prompt.

In the simplest form you read the data and store them in an object
you can work with in R. How to store data in an R object, we have already learned
in the previous lecture. You invent a name and assign the values to this name using the 
assignment operator `<-`.

Let's call the
object in which we save our data `energy_consumption`, then by calling the function `read.csv()` with the
path to your file as an argument will read the data from your local folder and store them in the
object we have created. This allows us to refer to the data for doing further computations.
```{r}
#| code-fold: false
energy_consumption <- read.csv("data/energy_use_per_capita/per-capita-energy-use.csv")
```
The function needs as an argument the file name. If the file is in a sub-folder
of  the current directory you need to also specify the path.
To specify the correct path to the file
you need to know in which part of your directory tree you are currently working.

In my
case I am working in the project folder for my lecture notes, which has a sub-folder called
`data`. The data sub-folder has a further sub-folder called `energy_use_per_capita` in my case
and thus I specify the path relative to this location. 

To find out what is your current
R working directory, R provides the function `getwd()`. If I type this in my case, I will get
```{r}
#| code-fold: false
getwd()
```
the path of my project folder for this lecture notes. So if I type the string
`"data/energy_use_per_capita/per-capita-energy-use.csv"` this specifies the path relative to my working directory.

If you read the file on your computer, you need to specify the path appropriately from where
you are working in R at the moment to where you have stored the csv file.

Now `read.csv()` has many additional arguments, which provide you with lots of
flexibility. I encourage you to check it out and play with it using the help function and
the examples given therein by typing `?read.csv` at the prompt.

We have now read the primary energy consumption data and written it to the 
R-object `energy_consumption`. Lets
inspect the object a bit to see what we've got. 

I use the function `head()` with
the parameter value `n = 10`. This will show me the first 10 rows of the data-file.
So the value I give to the argument `n` contros how many rows will be displayed.
```{r}
#| code-fold: false
options(width = 120)
head(energy_consumption, n = 10)
```
This gives you an idea what the data look like. There are four variables, called `Entity`, `Code`, `Year` and `Primary.energy.consumption.per.capita..kWh.person.` The last variable name is very informative
but also very long and unpractical. We will learn how to change variable names soon. Because of the
long name, I had to use the function `options()` before `heads()` to tell R to use a sufficiently wide
display. Don't worry for this detail at the moment.

### R objects {#sec-robjects}

The most basic type of R objects are **atomic vectors**. Objects in R are built
from atomic vectors. 

The energy consumption data-file we have just loaded is an example of such
a more complex structure built from atomic vectors. We have already encountered a few of
those in our previous lecture.

#### Atomic vectors {#sec-atomic}

An atomic vector is just a simple vector of data. For example remember when we typed the
infant mortality data for eight European countries for 1860 we typed
```{r}
#| code-fold: false
mr_1860 <- c(0.237, 0.139, 0.136, 0.150, 0.260, 0.102, 0.174, 0.124)
```
In this case `mr_1860` is an atomic vector. 

R has a function, which allows you to check whether an object is an atomic vector or not.
This function is called `is.vector()`. It takes the object name as an argument and returns `TRUE`
if the object is an atomic vector and `FALSE` if it is not. 

For example:
```{r}
#| code-fold: false
is.vector(mr_1860)
```
does indeed return `TRUE`.

Each atomic vector stores values in a one-dimensional vector, and each atomic vector can
only store one type of data. The length of the atomic vector can be determined by the
function `length()` This function takes an R object, which is an atomic vector, as an
argument and returns the number of elements in this vector. Here is the example of the die
```{r}
#| code-fold: false
length(mr_1860)
```
which is 8 as it should be. An atomic vector could also have only one element, in which case
`lenght()`would return 1.

#### Data types {#sec-datatypes}

Now altogether R has implemented *six basic types of atomic vectors*:

1. double

2. integers

3. characters

4. logical

5. complex

6. raw

We will not encounter complex and raw data-types in this course, so let us skip those and discuss
only the first 4 types, double, integer, character and logical.

If yo u go back to our energy consumption data and look at the first three lines
```{r}
options(width = 120)
head(energy_consumption, n=3)
```

you will see the different variables in the object `energy_consumption`. Note that I had to fudge a bit
with the display because of the unwieldy and long name of the last variable. We are soon going to fix this.

The variables `Entity`  and `Code` are both of type *character*.  A character vector stores 
strings of text, which have to be put between quotation marks `""`. Strings are the 
individual elements of a character vector.

Note that a string can be more than just letters. If you type, for instance the number `1` with
quotation marks, like `"1"` R would interpret the value as a string not as a number. Sometimes
one can get confused in R because both objects and characters appear as text in R code. Object
names are without quotation marks strings always are between quotation marks.

Character is the natural data type for country names - here "Afghanistan" and the international abbreviation "AFG" also called an ISO-country code^[ISO is the short name for International Organization for Standardization. International Organization for Standardization came into existence in the year 1946 in London. This organization was formed after a delegation of 65 members from 25 countries, met to discuss the future of International Standardization. In 1947, ISO was officially formed with 67 technical committees consisting of a group of experts focusing on a specific subject. ISO founders decided to give it an acronym ISO, which was based on the Greek word ‘isos’, which means ‘equal’.] 

The variable `Year` encodes the year of a particular record or observation. 
Its type is `integer`, since years are integer values like 1980 or
2022. If yo want to specify a number explicitly as integer in R you have to type it as, say, `1980L`, the number followed without space by a big `L`.

The variable with the very long name `Primary.energy.consumption.per.capita..kWh.person.` is of type
double. This is the data type in R for encoding numbers that are decimal fractions, like `12.451`

Now why should we care for distinguishing integers from doubles? This has to do with the
way a computer does computations. Sometimes a difference in precision can have surprising effects.

In your computer 64bits of memory^[A bit is a binary digit, the smallest increment of data on a computer. A bit can hold only one of two values: 0 or 1, corresponding to the electrical values of off or on, respectively. So 64 bits are sequences of 0 or 1 with a length of 64] are allocated 
for each double in an R program. While this
allows for a very precise representation of numbers not all numbers can be exactly represented
with 64-bits. The famous candidates are $\pi$, which has an infinite sequence of digits and must
therefore be rounded by the computer. Usually the rounding error introduced into your
computations will go unnoticed but sometimes surprises can occur. 

Take for instance:
```{r}
#| code-fold: false
sqrt(2)^2 - 2
```
Why is that? The square root of 2 can not be expresses precisely because, as already
the old Greeks
knew, it is not a rational number.^[Let me invite you to a short digression into the history of science and the history of ideas. The discovery that $\sqrt{2}$ can not be rational was a shock discovery to the ancient Greeks. The Greek mathematician Pythagoras and his followers were fascinated by and devoted to whole numbers. They detected the fundamental role played by ratios of whole numbers for musical harmony. For example dividing a vibrating string in two half raises the pitch by an octave, dividing the string in three raises the pitch by one fifths and so on. This discovery gave them the clue that the physical world as a whole might have an underlying mathematical structure governed by whole-number patterns. It was thus quite a shock when they
found out that one of their foundational discoveries the Pythagorean theorem logically implied that there
were ratios of lengths that were incommensurable, that is, not measurable as integer multiples of the
same unit. The ratio between such lengths is therefore not a ratio of whole numbers. This is why the Greeks called these numbers irrational. Some of you will remember from school that the Pythagorean theorem says that in a right angled triangle with lengths $a$, $b$ and $c$, where the sides with length $a$ and $b$ from a right angle must fulfill the equation $a^2 + b^2 = c^2$ or expressed in a picture
![The Pythagorean theorem](pictures/pythagoras.png){#fig-pyth}
The incommensurable lengths disovered by one member of the pythagorean school was the side and the diagonal of the unit square. By the Pythagorean theorem in a square with side length of 1 it must be the case that
$\text{(lenght of diagonal)}^2 = 1 + 1 = 2$. Thus the length of the diagonal must be
$\sqrt{2}$.
![Length of diagonal in a unit square](pictures/unit_square.png){#fig-usq}
Hence if the diagonal and side are in the ratio $m/n$ (where $m$ and $n$ can be assumed to have no common divisor), we have
\begin{equation}
m^2/n^2 = 2
\end{equation}
thus
\begin{equation}
m^2 = 2 n^2
\end{equation}
This equation implies that $m^2$ must be an even number. So $m$ must be even too, say $m = 2 p$. But if
\begin{equation}
m = 2 p
\end{equation}
then we have
\begin{equation}
2 n^2 = m^2 = 4 p^2
\end{equation}
hence
\begin{equation}
n^2 = 2 p^2
\end{equation}
which similarly implies that $n$ is even. But we began the chain of deductions 
by the assumption that $m$ and $n$ have no common divisor. So if both $m$ and $n$ were even
they would have a common divisor, namely 2. We have arrived at a contradiction. This means the length
of the diagonal of the unit square can not be a rational number. Legend has it that th first Pythagorean to make the result public was drowned at sea. But even if the Pythagoreans could not accept that $\sqrt{2}$
was a number, no one could deny that it was the length of the diagonal of the unit square.] 

And you have a small rounding error. Let me explain to those of you who are puzzled by the
meaning of this output. R displays the result of its computation in scientific notation. `4.440892e-16`
means $4.44089 \times 10^{-16}$. 

For those of you who forgot how exponential notation works, let me remind you that we write $10^{-1}$ for $1/10$ and $10^{-2}$ means $1/10^2$ or $1/100$. Thus $10^{-16}$ means
$1/10.000.000.000.000.000$, a very small number but still different from 0. This is the error introduced
by rounding $\sqrt{2}$.
Such errors
are called *floating point errors* in computer science lingo and computing with such numbers is
called *floating-point-arithmetic*.

With integers floating point errors are avoided, but for many applications this is not an
option. Luckily for most cases floating-point arithmetic provides sufficient precision
for most of the applications we encounter in practice.

The last data type in the list, we want to discuss here, are: **Logicals**. 
Logical vectors store `TRUE` and `FALSE`; logical values. They
are extremely useful for doing comparisons and - as we will see shortly - also for
selecting values from a data set.

How logical data types work can best be understood by an example. If you type, for instance:
```{r}
#| code-fold: false
0 > 1
```
R tells you that this statement is false, by printing the logical value `FALSE` 
as an output.

Whenever you type `TRUE` of `FALSE` without quotation marks, R will treat the
input as logical data. Note, as an aside, if you typed `"TRUE"`and `"FALSE"` in quotation marks, R 
would
treat this input as a string co characters, a different data type. When communicating
with a computer, you need to be very precise or the machine will not understand what
you want to tell it do.

For instance, the following statement yields:

```{r}

#| code-fold: false
logic <- c(TRUE, FALSE, TRUE)
logic
```


#### Attributes {#sec-attributes}

One important R-fact which you need to know about atomic vectors is that atomic vectors
can have **attributes**. Attributes won't affect the values of an object but can hold
and store object metadata. 

Normally we do not look at these metadata, but many R functions
check for attributes and then do special things with the object depending on these
attributes. Attributes can be checked with the function `attributes()` using an R object as an argument.
This will show you all the attributes that are attached to an R object.

The most common attributes for atomic vectors as well as R objects built from
atomic vectors are **names**, **dimensions** and **classes**.
Each of these attributes has its own helper function that you can use to also assign attributes to
the object. For what we need now we discuss `names` and `dimensions` and discuss `classes`, which is
a more advanced topic later.

Let us look how this works with the `enegrgy_consumption`data and check whether 
they have a names attribute:

```{r}
#| code-fold: false
names(energy_consumption)
```

We can now see the variable names. We can use the function `names()`also as a
helper function to assign other names to our variables. This is a tool that could
help us to get rid of the very long and
unwieldy name `"Primary.energy.consumption.per.capita..kWh.person."`. For example:
```{r}
#| code-fold: false
names(energy_consumption) <- c("Entity", "Code", "Year", "Cons")
```
will overwrite the name attribute by this new vector of names. When you now look for the
names attribute, you will see

```{r}
names(energy_consumption)
```

One very important attribute, we will encounter all the time is **dimension**, with the
helper function `dim()`. For example we can look at our data object `energy_consumption` again
to get:
```{r}
dim(energy_consumption)
```
which returns two numbers, which mean that the object has 10215 rows and 4 columns.

#### Factors

R stores categorical data, such as nationality, sex etc. by using aspeical data type
called **factors**. If
you take for instance, sex, it can have only two values - male or female - and these
values may have their idiosyncratic order, for example that females go always first.

To make a factor in R you have to pass an atomic vector to the `factor()` function.
This function works by recoding the values in the vector as integers and store the
results in an integer vector. R also adds a `level` attribute which contains the set
of labels and their order and a class attribute that says the vector is
a factor. Example:
```{r sex-factor}
sex <- factor(c("m", "f", "f", "m"))
typeof(sex)
attributes(sex)
```
Factors can be confusing since they look like characters but behave like integers.

Note that R will often try to convert character strings to factors when you load and create data.
I recommend that you do not allow R to make factors unless you explicitly ask for it. This
can usually be controlled by an argument to whatever the data reader function is. For instance
you can give the `read.csv()` function the argument `stringsAsFactors = FALSE`.

R has an internal **coercion** behavior for data types, which you should know
about if you work with R. With this knowledge you can do many useful things.

If a character string is present in an atomic vector, R will automatically convert every
other component in this vector to a character string. If a vector contains only logicals
and numbers, R will convert the logicals to numbers. In this case every `TRUE` becomes a 1 and
every `FALSE` becomes a 0.

R also uses the coercion rules, when we do math with logicals, like for example
```{r math-with-logicals}
sum(c(TRUE, TRUE, FALSE, FALSE))
```
What happens here is that R coerces the vector `c(TRUE, TRUE, FALSE, FALSE)` to the
vector `c(1, 1, 0, 0)` and sums the components.

### Data frames and R lists {#sec-data_frame}

Going back to our data set on the enegry consumption data, we see that this data set stores
values of different types, characters, integers and doubles. How does R achieve this?

The answer is that this is achieved by a data structure called a **list**. List are
like atomic vectors, because the group data into a one-dimensional set. However, lists do
not group together individual values. List group together R objects, such as atomic
vectors or even other lists.

For example, you can create a list, which contains a numeric vector of length 31 in its
first element, a character vector of length 1 in its second element and a new list of length 2 in its third. This is done by using the `list()`function of R, like this:
```{r}
#| code-fold: false
list_example <- list(100:130, "R", list(TRUE, FALSE))
list_example
```
The double bracketed indices tell you which element of the list is being displayed. The
single bracketed indices tell you which sub-element of the list is being displayed. For example
100 is the first sub element of the first element in the list. "R" is the first sub element of the
second list element.

There is lots to say about lists. But this is an advanced topics. We mentioned it here to
introduce one of the most important data structres for our course the R dataframe.

### Data Frames

**Data Frames** are the two dimensional version of a list. They are by far the most
useful storage structure for data analysis. Indeed, our dataset on energy
consumption data we have loaded before is an instance of a data frame. Data frames group vectors
together in a two dimensional table. As a consequence each variable can have a different type, 
i.e. each column of the
data frame can contain a different data type. Within a column, however, we can have only
one data type. The energy consumption data are a typical example of a dataframe.

```{r}
head(energy_consumption, n = 10)
```

Every column in this tabular array of data can be considered as a vector. 


### Selecting data from a dataframe: Asking some questions about per capita primary energy use.

Asking questions about a dataframe and in particular about our energy data requires that 
we are able to adress particular values in the dataframe. We now learn the most 
important techniques to do so.

R has a notation system to address individual values. You write the object name first, followed by a 
pair of had brackets `[]`. Between the brackets goes a `,` separating row and column indices. The
notation is thus like `energy_consumption[,]`.

When it comes to writing the indices you have six different ways to do this, all of them very simple. You can use:

1. Positive integers
2. Negative integers
3. Zero
4. Blank spaces
5. Logical values
6. Names

The simplest are positive integers. When you want to extract the energy consumption in kwh per person 
in one year - the value of the variable Cons - you would adress for instance the 3rd value in the
Cons column, which is in our case the 4th column as

```{r}
#| code-fold: false
energy_consumption[3,4]
```

You can - of course extract more than one value. If you write for instance

```{r}
#| code-fold: false

energy_consumption[1:5,4]
```
you will get the first 5 values of the consumption numbers in the dataframe. The colon
operator `:` used here is a very useful R operator. It creates sequences of whole
numbers. Thus if you create a vector with the name, say `n10` containing the sequence
of the first 10 whole numbers, you would write

```{r}
#| code-fold: false
n10 <- 1:10
```

Now clearly the indexing rules work in the same way as with dataframes, only that now you have 
only 1 dimension. Say you want to extract the first three numbers from `n10` you would write

```{r}
#| code-fold: false
n10[1:3]
```

Note that R’s notation system is not limited to data frames. The same syntax can be used to select values from any R object, provided you supply an index for each dimension of the object. Two things have to be kept in mind. In R indexing begins at 1. In some other programming languages indexing begins at 0. The indexing convention in R is just like in linear algebra. The second thing to note is that if you select two or more columns from a data frame, R will return a new data frame, like in

```{r}
#| code-fold: false

energy_consumption[1:5, 3:4]
```

 R will always return a dataframe. 
 
However, if you select a single column, R will return a vector:

```{r}
#| code-fold: false

energy_consumption[1:5, 4]
```

if you prefer to get returned a data frame in this case, you have to add the argument drop = FALSE, like:

```{r}
energy_consumption[1:5, 4, drop = FALSE]
```

<!-- ## Contents  -->

<!-- Statistics usually involves lots of data and we need ways to communicate and summarize these data. This -->
<!-- chapter introduces the most important concepts. -->


<!-- 1. The empirical distribution of data points -->
<!-- 2. Measures of location and spread. -->
<!-- 3. Skewed data distributions are common and some summary statistics are very sensitive to outlying values.  -->
<!-- 4. Summaries always hide some detail.  -->
<!-- 5. How to summarize sets of numbers graphically (histograms and box plots) -->
<!-- 6. Useful transformations to reveal patterns -->
<!-- 7. Looking at pairs of numbers, scatter plots, time series as line graphs.  -->
<!-- 8. The primary aim in data exploration is to get an idea of the overall variation. -->

<!-- ## Next steps in R: -->

<!-- - vectors and indices -->
<!-- - extracting subsets from vectors -->
<!-- - creating vectors using c() -->
<!-- - subsetting vectors wit logicals -->
<!-- - data frames -->
<!-- - factor class -->
<!-- - extracting data from data frames -->
<!-- - tapply -->



<!-- ## Outcome  -->

<!-- Understand these concepts and work through may examples showing how to apply these summary measures to data on the -->
<!-- computer. -->